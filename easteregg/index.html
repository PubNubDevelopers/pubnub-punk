<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PUNK â€“ PubNub Ultimate Ninja Kit</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    :root {
      --bg-light: #f9f9f9;
      --bg-dark: #070f39;
      --red: #c71929;
      --blue: #528dfa;
      --text-dark: #171717;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg-dark);
      overflow: hidden;
      font-family: 'Orbitron', monospace;
      cursor: crosshair;
    }

    #punkCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Cyber grid background */
    #cyberGrid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.15;
      background-image: 
        linear-gradient(var(--blue) 1px, transparent 1px),
        linear-gradient(90deg, var(--blue) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: gridScroll 20s linear infinite;
    }

    @keyframes gridScroll {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }

    /* Title overlay with glitch effect */
    #titleOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: 900;
      font-size: clamp(2rem, 8vw, 5rem);
      letter-spacing: 0.15em;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      mix-blend-mode: screen;
      animation: fadeInTitle 2s ease-out 1s forwards;
    }

    @keyframes fadeInTitle {
      to { opacity: 1; }
    }

    .title-line {
      display: block;
      position: relative;
      color: var(--blue);
      text-shadow: 
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 80px currentColor;
      animation: glitchText 8s infinite;
    }

    .title-line .initial {
      color: var(--red);
      text-shadow: 
        0 0 10px var(--red),
        0 0 20px var(--red),
        0 0 40px var(--red),
        0 0 80px var(--red);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes glitchText {
      0%, 95% { 
        transform: translate(0);
        filter: hue-rotate(0deg);
      }
      95.5% { 
        transform: translate(2px, -2px);
        filter: hue-rotate(90deg);
      }
      96% { 
        transform: translate(-2px, 2px);
        filter: hue-rotate(-90deg);
      }
      96.5%, 100% { 
        transform: translate(0);
        filter: hue-rotate(0deg);
      }
    }

    /* Glitch overlay */
    .glitch-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      mix-blend-mode: screen;
      animation: glitchOverlay 10s infinite;
    }

    @keyframes glitchOverlay {
      0%, 90% { opacity: 0; }
      91% { opacity: 0.1; background: linear-gradient(transparent 50%, var(--red) 50%); }
      92% { opacity: 0.05; background: linear-gradient(90deg, transparent 50%, var(--blue) 50%); }
      93%, 100% { opacity: 0; }
    }

    /* Loading sequence */
    #loadingSequence {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: var(--blue);
      font-family: 'Courier New', monospace;
      opacity: 0;
      animation: loadingFade 3s ease-out;
    }

    @keyframes loadingFade {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }

    .loading-line {
      margin: 2px 0;
      opacity: 0;
      animation: typeIn 0.5s ease-out forwards;
    }

    @keyframes typeIn {
      to { opacity: 1; }
    }

    /* Epic entrance flash */
    #flashOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, var(--blue) 0%, transparent 70%);
      pointer-events: none;
      opacity: 0;
      animation: epicFlash 2s ease-out 0.5s;
    }

    @keyframes epicFlash {
      0% { opacity: 0; transform: scale(0.5); }
      50% { opacity: 0.8; transform: scale(1.2); }
      100% { opacity: 0; transform: scale(1); }
    }

    /* Mouse trail effect */
    .particle-trail {
      position: absolute;
      width: 4px;
      height: 4px;
      background: var(--red);
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 10px var(--red);
      animation: particleFade 1s ease-out forwards;
    }

    @keyframes particleFade {
      to {
        transform: translateY(20px);
        opacity: 0;
      }
    }
  </style>

  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap" rel="stylesheet"/>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="cyberGrid"></div>
  <div id="flashOverlay"></div>
  
  <div id="loadingSequence">
    <div class="loading-line" style="animation-delay: 0.1s">[INITIALIZING PUNK SYSTEM...]</div>
    <div class="loading-line" style="animation-delay: 0.3s">[LOADING NINJA PROTOCOLS...]</div>
    <div class="loading-line" style="animation-delay: 0.5s">[ESTABLISHING PUBNUB CONNECTION...]</div>
    <div class="loading-line" style="animation-delay: 0.7s">[QUANTUM PARTICLES ALIGNED...]</div>
    <div class="loading-line" style="animation-delay: 0.9s">[SYSTEM READY]</div>
  </div>

  <canvas id="punkCanvas"></canvas>
  
  <div class="glitch-overlay"></div>
  
  <div id="titleOverlay">
    <span class="title-line">
      <span class="initial">P</span>UBNUB
    </span>
    <span class="title-line">
      <span class="initial">U</span>LTIMATE
    </span>
    <span class="title-line">
      <span class="initial">N</span>INJA
    </span>
    <span class="title-line">
      <span class="initial">K</span>IT
    </span>
  </div>

  <script type="module">
  import * as THREE from 'three';
  import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
  import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
  import { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler.js';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.2/+esm';

  /* Core setup */
  const renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById('punkCanvas'),
    antialias: true,
    alpha: false
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.5;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x070f39, 100, 400);

  const camera = new THREE.PerspectiveCamera(
    50,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 150);

  /* Epic lighting setup */
  scene.add(new THREE.AmbientLight(0x528dfa, 0.3));
  
  const mainLight = new THREE.DirectionalLight(0xffffff, 1);
  mainLight.position.set(0, 50, 50);
  scene.add(mainLight);

  const redSpotlight = new THREE.SpotLight(0xc71929, 2, 200, Math.PI / 4, 0.5);
  redSpotlight.position.set(-50, 50, 100);
  scene.add(redSpotlight);

  const blueSpotlight = new THREE.SpotLight(0x528dfa, 2, 200, Math.PI / 4, 0.5);
  blueSpotlight.position.set(50, -50, 100);
  scene.add(blueSpotlight);

  /* Post-processing bloom */
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.5,
    0.4,
    0.85
  );
  bloomPass.threshold = 0.2;
  bloomPass.strength = 2;
  bloomPass.radius = 0.8;
  composer.addPass(bloomPass);

  /* Mouse tracking */
  const mouse = new THREE.Vector2();
  const mouseWorldPos = new THREE.Vector3();
  
  window.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    
    // Create particle trail
    if (Math.random() > 0.8) {
      const trail = document.createElement('div');
      trail.className = 'particle-trail';
      trail.style.left = e.clientX + 'px';
      trail.style.top = e.clientY + 'px';
      document.body.appendChild(trail);
      setTimeout(() => trail.remove(), 1000);
    }
  });

  /* Responsive handling */
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });

  /* Particle system configuration */
  const PARTICLE_COUNT = 15000;
  const COLORS = {
    red: new THREE.Color('#c71929'),
    blue: new THREE.Color('#528dfa'),
    white: new THREE.Color('#f9f9f9')
  };

  /* Load font and create particles */
  const loader = new FontLoader();
  loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (font) => {
    
    /* Sample points from text geometry */
    const sampleTextPoints = (text, size, count) => {
      const geometry = new TextGeometry(text, {
        font,
        size,
        height: 4,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.5,
        bevelSize: 0.3,
        bevelSegments: 8
      });
      geometry.center();
      
      const mesh = new THREE.Mesh(geometry);
      const sampler = new MeshSurfaceSampler(mesh).build();
      
      const points = [];
      const tempVector = new THREE.Vector3();
      
      for (let i = 0; i < count; i++) {
        sampler.sample(tempVector);
        points.push(tempVector.clone());
      }
      
      return points;
    };

    /* Create point sets */
    const titlePoints = sampleTextPoints('PUBNUB ULTIMATE NINJA KIT', 8, PARTICLE_COUNT);
    const punkPoints = sampleTextPoints('PUNK', 25, PARTICLE_COUNT);
    
    /* Initialize particle buffers */
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const sizes = new Float32Array(PARTICLE_COUNT);
    const velocities = new Float32Array(PARTICLE_COUNT * 3);
    
    /* Random initial positions */
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const i3 = i * 3;
      
      // Explosion start positions
      const radius = Math.random() * 200;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      
      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i3 + 2] = radius * Math.cos(phi);
      
      // Initial velocities for explosion effect
      velocities[i3] = (Math.random() - 0.5) * 2;
      velocities[i3 + 1] = (Math.random() - 0.5) * 2;
      velocities[i3 + 2] = (Math.random() - 0.5) * 2;
      
      // Color distribution (40% red, 60% blue)
      const isRed = Math.random() < 0.4;
      const color = isRed ? COLORS.red : COLORS.blue;
      colors[i3] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
      
      sizes[i] = Math.random() * 3 + 1;
    }
    
    /* Create particle geometry */
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
    
    /* Custom shader material */
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        mousePos: { value: new THREE.Vector3() }
      },
      vertexShader: `
        attribute float size;
        attribute vec3 velocity;
        varying vec3 vColor;
        uniform float time;
        uniform vec3 mousePos;
        
        void main() {
          vColor = color;
          vec3 pos = position;
          
          // Mouse influence
          float mouseDist = distance(pos, mousePos);
          if (mouseDist < 50.0) {
            vec3 push = normalize(pos - mousePos) * (50.0 - mouseDist) * 0.5;
            pos += push;
          }
          
          // Oscillation
          pos += velocity * sin(time * 2.0) * 0.5;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        
        void main() {
          float r = distance(gl_PointCoord, vec2(0.5));
          if (r > 0.5) discard;
          
          float opacity = 1.0 - smoothstep(0.0, 0.5, r);
          gl_FragColor = vec4(vColor, opacity);
        }
      `,
      transparent: true,
      vertexColors: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
    
    /* Animation state */
    const animState = {
      titleProgress: 0,
      punkProgress: 0,
      explosionForce: 1,
      rotationSpeed: 1,
      colorShift: 0
    };
    
    /* Epic animation timeline */
    const tl = gsap.timeline({ delay: 1 });
    
    // Initial explosion
    tl.to(animState, {
      explosionForce: 0,
      duration: 2,
      ease: "expo.out",
      onUpdate: () => {
        const force = animState.explosionForce;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          positions[i3] *= 1 + force * 0.02;
          positions[i3 + 1] *= 1 + force * 0.02;
          positions[i3 + 2] *= 1 + force * 0.02;
        }
        geometry.attributes.position.needsUpdate = true;
      }
    })
    
    // Form title text
    .to(animState, {
      titleProgress: 1,
      duration: 3,
      ease: "power3.inOut",
      onUpdate: () => {
        const t = animState.titleProgress;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          const target = titlePoints[i];
          
          positions[i3] = THREE.MathUtils.lerp(positions[i3], target.x, t);
          positions[i3 + 1] = THREE.MathUtils.lerp(positions[i3 + 1], target.y, t);
          positions[i3 + 2] = THREE.MathUtils.lerp(positions[i3 + 2], target.z, t);
        }
        geometry.attributes.position.needsUpdate = true;
      }
    })
    
    // Hold and pulse
    .to(animState, {
      rotationSpeed: 0.2,
      duration: 2
    })
    
    // Morph to PUNK
    .to(animState, {
      punkProgress: 1,
      colorShift: 1,
      duration: 3,
      ease: "expo.inOut",
      onUpdate: () => {
        const t = animState.punkProgress;
        const c = animState.colorShift;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          const titlePos = titlePoints[i];
          const punkPos = punkPoints[i];
          
          positions[i3] = THREE.MathUtils.lerp(titlePos.x, punkPos.x, t);
          positions[i3 + 1] = THREE.MathUtils.lerp(titlePos.y, punkPos.y, t);
          positions[i3 + 2] = THREE.MathUtils.lerp(titlePos.z, punkPos.z, t);
          
          // Shift all colors to red
          colors[i3] = THREE.MathUtils.lerp(colors[i3], COLORS.red.r, c);
          colors[i3 + 1] = THREE.MathUtils.lerp(colors[i3 + 1], COLORS.red.g, c);
          colors[i3 + 2] = THREE.MathUtils.lerp(colors[i3 + 2], COLORS.red.b, c);
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
      }
    })
    
    // Final pulse
    .to(bloomPass, {
      strength: 4,
      duration: 0.5,
      yoyo: true,
      repeat: 1,
      ease: "power2.inOut"
    });
    
    /* Render loop */
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      
      const time = clock.getElapsedTime();
      const delta = clock.getDelta();
      
      // Update uniforms
      material.uniforms.time.value = time;
      
      // Convert mouse to world position
      mouseWorldPos.set(mouse.x * 100, mouse.y * 100, 0);
      material.uniforms.mousePos.value = mouseWorldPos;
      
      // Rotate scene
      particleSystem.rotation.y += delta * animState.rotationSpeed * 0.1;
      particleSystem.rotation.x = Math.sin(time * 0.2) * 0.1;
      
      // Camera movement
      camera.position.x = Math.sin(time * 0.1) * 10;
      camera.position.y = Math.cos(time * 0.1) * 10;
      camera.lookAt(0, 0, 0);
      
      // Light animation
      redSpotlight.position.x = Math.sin(time) * 100;
      redSpotlight.position.z = Math.cos(time) * 100;
      blueSpotlight.position.x = Math.cos(time) * 100;
      blueSpotlight.position.z = Math.sin(time) * 100;
      
      composer.render();
    }
    
    animate();
  });
  </script>
</body>
</html>